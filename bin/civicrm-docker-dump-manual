#!/bin/env php
<?php

// Initialise variables
$pwd = $_SERVER['PWD'];
$projectName = basename($pwd);

// Read arguments (if any)
$shortopts = "c:s:h";
$longopts = [
    "config-file:",
    "state-path:",
    "help"
];

$options = getopt($shortopts, $longopts);

// Show the help
if (isset($options["h"]) || isset($options["help"])) {
  echo "
# Usage

## Default

Executing `civicrm-docker-dump-manual` without parameters
will 1) read `civicrm-docker-dump-manual.json` from the
current working directory and 2) generate a dump in the
`state` folder, also relative to the current working directory.

## Help

Executing the script with `-h` or `--help` will show this help:

```
civicrm-docker-dump-manual -h
civicrm-docker-dump-manual --help
```

## Config

Executing the script with `-c` or `--config-file` will allow
to specify a different configuration file:

```
civicrm-docker-dump-manual -c /project/civicrm-docker-dump-manual.json
```

## State

Executing the script with `-s` or `--state-path` will allow
to specify a different configuration file:

```
civicrm-docker-dump-manual -s /project/state
```

Please, don't add a trailing slash at the end.

";

  exit;
}

// Choose the definitions file
if (isset($options["c"]) && empty($options["config-file"])) {
  $options["config-file"] = $options["c"];
}

if (isset($options["config-file"])) {
  $definitionFile = $options["config-file"];
} else {
  $definitionFile = "$pwd/civicrm-docker-dump-manual.json";
}

// Choose the state folder
if (isset($options["s"]) && empty($options["state-path"])) {
  $options["state-path"] = $options["s"];
}

if (isset($options["state-path"])) {
  $statePath = $options["state-path"];
} else {
  $statePath = "$pwd/state";
}

// Warn if we do not have a valid project name
if (!strlen($projectName)) {
    trigger_error("Could not detect project name", E_USER_WARNING);
}
$tempDir = "/tmp/civicrm-docker-dump.$projectName";
$dumpScript = "/tmp/civicrm-docker-dump.$projectName.sync.sh";

// Load definition from json
$definition = json_decode(file_get_contents($definitionFile), 1);


// Create temp directory
$lines[] = "rm -rf {$tempDir}";
$lines[] = "mkdir {$tempDir}";

// Dump databases
foreach ($definition['databases'] as $dbKey => $database) {
    // TODO: consider compressing these while in transit
    if (isset($database['defaults_extra_file'])) {
        $lines[] = "ssh {$projectName} mysqldump --defaults-extra-file={$database['defaults_extra_file']} --single-transaction --skip-triggers {$database['name']} > {$tempDir}/{$dbKey}.sql";
    } else {
        $lines[] = "ssh {$projectName} mysqldump --single-transaction --skip-triggers {$database['name']} > {$tempDir}/{$dbKey}.sql";
    }
}

// Tar files
foreach ($definition['directories'] as $dirKey => $directory) {
    $lines[] = "ssh {$projectName} tar -cz -C {$directory['src']} . > {$tempDir}/{$dirKey}.tar.gz";
}

// Generate state.json
$lines[] = "cat << EOF > {$tempDir}/state.json";
$state = [
    'project' => $projectName,
    'databases' => array_keys($definition['databases']),
    'directories' => array_map(function ($dir) {
        return $dir['dest'];
    }, $definition['directories']),
];
$lines[] = json_encode($state, JSON_PRETTY_PRINT);
$lines[] = "EOF";
$lines[] = "OUTFILE={$projectName}.$(date +%Y%m%dT%H%M%S).tar.gz";
$lines[] = "tar -cz -C {$tempDir} . -f ${statePath}/\${OUTFILE}";
$lines[] = "echo \$OUTFILE";
$lines[] = "rm -rf {$tempDir}";

// Abort if we have encountered any errors (e.g. due to missing variables in
// the json definition, etc.)
if (error_get_last()) {
    echo "Some errors occured - aborting manual dump.\n";
    exit;
}
//TODO: add -d --dry-run option to print echo rather than execute commands
file_put_contents($dumpScript, implode("\n", $lines) . "\n");
passthru("bash $dumpScript");
unlink($dumpScript);
